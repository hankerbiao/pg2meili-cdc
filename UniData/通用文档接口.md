# 通用文档接口说明

UniData 提供一组通用文档接口，用于在单一入口下管理任意集合（collection）的业务文档，例如：

- requirements：需求文档
- bugs：缺陷单
- settings：用户配置
- uni_documents：统一存储文档集合

接口统一挂载在：

- 基础路径：`/api/v1/data`
- 每个集合通过路径参数 `/{collection}` 进行区分

所有接口均需要携带 JWT 鉴权，使用 `Authorization: Bearer {token}`。

---

## 一、接口列表

1. 创建/更新文档  
   `POST /api/v1/data/{collection}`

2. 获取单个文档详情  
   `GET /api/v1/data/{collection}/{id}`

3. 逻辑删除文档（数据库层）  
   `DELETE /api/v1/data/{collection}/{id}`

4. 列出集合下的文档列表  
   `GET /api/v1/data/{collection}`

---

## 二、公共约定

### 2.1 路径参数 `collection`

- 类型：`string`
- 位置：Path
- 必填：是
- 说明：
  - 表示文档所属集合名称，例如：`requirements`、`bugs`、`uni_documents`
  - **不能包含空格**；包含空格会返回 `400 collection 名称不能包含空格`

命名建议：

- 全小写
- 使用下划线分隔：`user_settings`、`project_docs`
- 尽量使用复数：`requirements`、`bugs`

### 2.2 路径参数 `id`

- 类型：`string`
- 位置：Path
- 必填：是（除创建/更新接口以外）
- 说明：文档唯一标识，同一 `collection` 内唯一

### 2.3 鉴权说明

- Header：`Authorization: Bearer {token}`
- Token 内容中必须包含 `app_name` 字段，服务端会将其写入文档的 `app_name` 字段，并用于索引隔离。

---

## 三、创建/更新文档

### 3.1 请求语法

```http
POST /api/v1/data/{collection} HTTP/1.1
Host: {host}
Authorization: Bearer {token}
Content-Type: application/json
```

### 3.2 请求参数

| 名称         | 类型   | 位置   | 必填 | 说明                          |
| ------------ | ------ | ------ | ---- | ----------------------------- |
| collection   | string | Path   | 是   | 集合名称，不能包含空格        |
| id           | string | Body   | 是   | 文档唯一标识                  |
| 其他业务字段 | any    | Body   | 否   | 任意 JSON 字段，将全部写入文档 |

- 请求体使用 `DocumentCreateRequest`，要求：
  - 必须包含 `id`
  - 其他字段不做限制（`extra="allow"`）

### 3.3 请求示例

```bash
curl -X POST "http://localhost:8080/api/v1/data/uni_documents" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_APP_JWT_TOKEN" \
  -d '{
    "id": "doc-001",
    "title": "示例文档",
    "status": "active",
    "tags": ["demo", "unidata"]
  }'
```

### 3.4 返回参数

返回体使用 `DocumentResponse`：

```json
{
  "status": "success",
  "id": "doc-001",
  "collection": "uni_documents"
}
```

字段说明：

| 名称       | 类型   | 说明          |
| ---------- | ------ | ------------- |
| status     | string | 固定为 success |
| id         | string | 文档 ID       |
| collection | string | 集合名称      |

---

## 四、获取文档详情

### 4.1 请求语法

```http
GET /api/v1/data/{collection}/{id} HTTP/1.1
Host: {host}
Authorization: Bearer {token}
```

### 4.2 请求参数

| 名称       | 类型   | 位置 | 必填 | 说明     |
| ---------- | ------ | ---- | ---- | -------- |
| collection | string | Path | 是   | 集合名称 |
| id         | string | Path | 是   | 文档 ID  |

### 4.3 请求示例

```bash
curl -X GET "http://localhost:8080/api/v1/data/uni_documents/doc-001" \
  -H "Authorization: Bearer YOUR_APP_JWT_TOKEN"
```

### 4.4 返回示例

服务端直接返回存储的 payload 内容，例如：

```json
{
  "id": "doc-001",
  "title": "示例文档",
  "status": "active",
  "tags": ["demo", "unidata"],
  "collection": "uni_documents",
  "app_name": "your_app"
}
```

- 其中 `collection` 和 `app_name` 为服务端注入字段，用于后续 CDC 与 Meilisearch 的索引路由。

---

## 五、删除文档（逻辑删）

### 5.1 请求语法

```http
DELETE /api/v1/data/{collection}/{id} HTTP/1.1
Host: {host}
Authorization: Bearer {token}
```

### 5.2 请求参数

| 名称       | 类型   | 位置 | 必填 | 说明     |
| ---------- | ------ | ---- | ---- | -------- |
| collection | string | Path | 是   | 集合名称 |
| id         | string | Path | 是   | 文档 ID  |

### 5.3 行为说明

- 服务端调用 `delete_document`：在数据库层将文档逻辑删除（例如设置 `is_delete = true`）。
- 下游链路：
  - Debezium 捕获 UPDATE 事件（`is_delete` 字段变为 true）；
  - Go 消费者检测到 `is_delete=true` 时，在 Meilisearch 中物理删除该文档。

### 5.4 返回示例

```json
{
  "status": "success",
  "id": "doc-001",
  "collection": "uni_documents"
}
```

---

## 六、列出集合文档

### 6.1 请求语法

```http
GET /api/v1/data/{collection}?limit={limit}&offset={offset} HTTP/1.1
Host: {host}
Authorization: Bearer {token}
```

### 6.2 请求参数

| 名称       | 类型   | 位置 | 必填 | 默认值 | 说明              |
| ---------- | ------ | ---- | ---- | ------ | ----------------- |
| collection | string | Path | 是   | -      | 集合名称          |
| limit      | int    | Query| 否   | 20     | 返回条数，1–100   |
| offset     | int    | Query| 否   | 0      | 偏移量，从 0 开始 |

### 6.3 返回示例

返回列表元素为各文档的 payload 内容，例如：

```json
[
  {
    "id": "doc-001",
    "title": "示例文档 1",
    "status": "active"
  },
  {
    "id": "doc-002",
    "title": "示例文档 2",
    "status": "draft"
  }
]
```

---

## 七、客户端调用示例（Python）

下面示例展示如何使用类似阿里云 SDK 的方式封装通用文档接口。

```python
import requests
import jwt
import time


class UniDataDocumentClient:
    def __init__(self, base_url: str, app_name: str, jwt_secret: str):
        self.base_url = base_url.rstrip("/")
        self.app_name = app_name
        self.jwt_secret = jwt_secret

    def _generate_token(self, ttl_seconds: int = 3600) -> str:
        payload = {
            "app_name": self.app_name,
            "scopes": ["read", "write"],
            "exp": int(time.time()) + ttl_seconds,
        }
        return jwt.encode(payload, self.jwt_secret, algorithm="HS256")

    def _request(self, method: str, path: str, **kwargs) -> dict:
        url = f"{self.base_url}/api/v1{path}"
        headers = kwargs.pop("headers", {})
        headers.setdefault("Authorization", f"Bearer {self._generate_token()}")
        headers.setdefault("Content-Type", "application/json")
        response = requests.request(method, url, headers=headers, **kwargs)
        response.raise_for_status()
        return response.json()

    def upsert_document(self, collection: str, data: dict) -> dict:
        if " " in collection:
            raise ValueError("collection 名称不能包含空格")
        if "id" not in data or not data["id"]:
            raise ValueError("文档必须包含非空的 id 字段")

        return self._request("POST", f"/data/{collection}", json=data)

    def get_document(self, collection: str, doc_id: str) -> dict:
        return self._request("GET", f"/data/{collection}/{doc_id}")

    def delete_document(self, collection: str, doc_id: str) -> dict:
        return self._request("DELETE", f"/data/{collection}/{doc_id}")

    def list_documents(self, collection: str, limit: int = 20, offset: int = 0) -> list[dict]:
        params = {"limit": limit, "offset": offset}
        return self._request("GET", f"/data/{collection}", params=params)
```

